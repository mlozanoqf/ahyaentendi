<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ai_fin</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="ai_fin_files/libs/clipboard/clipboard.min.js"></script>
<script src="ai_fin_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="ai_fin_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="ai_fin_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="ai_fin_files/libs/quarto-html/popper.min.js"></script>
<script src="ai_fin_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="ai_fin_files/libs/quarto-html/anchor.min.js"></script>
<link href="ai_fin_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="ai_fin_files/libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="ai_fin_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="ai_fin_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="ai_fin_files/libs/bootstrap/bootstrap-a3d08eff9b35980c3ade067cc1320f06.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">ai_fin</h1>
</div>



<div class="quarto-title-meta">

    
  
    <div>
    <div class="quarto-title-meta-heading">Modified</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">2026-02-18 03:14:53 CST</p>
    </div>
  </div>
    
  </div>
  


</header>


<section id="ia-en-finanzas-una-perspectiva-desde-la-empresa-y-la-investigación-financiera" class="level1">
<h1>IA en finanzas, una perspectiva desde la empresa y la investigación financiera</h1>
<p><strong>Referencia base</strong> Andrea L. Eisfeldt y Gregor Schubert. <em>Generative AI and Finance</em>. <em>Annual Review of Financial Economics</em> 17 (2025), 363-393.</p>
<p><strong>Última modificación</strong> 2026-02-18 03:14:53 CST.</p>
<p>La IA generativa funciona como un shock tecnológico simultáneo sobre las firmas y sobre los métodos de investigación en finanzas, en línea con el marco de Eisfeldt y Schubert (2025). En la empresa, el cambio ya se ve en hechos concretos. Aumentan las vacantes donde las empresas piden habilidades de IA, los mercados revalúan antes a los sectores más expuestos y los puestos se rediseñan al automatizar tareas estandarizables. En investigación, el giro más determinante es metodológico. Además de los datos numéricos tradicionales, ahora puede usarse de forma sistemática el contenido textual ligado a la actividad financiera, desde reportes y conferencias hasta documentos regulatorios. Eso amplía la frontera empírica con preguntas que antes quedaban fuera. Mirar solo uno de estos planos deja incompleta la dinámica económica que el propio paper documenta.</p>
<p>La adopción empresarial de herramientas de IA generativa en procesos de trabajo avanza con ritmos distintos y esa heterogeneidad es parte central del fenómeno. Una señal temprana y medible aparece en contratación. Tras el lanzamiento de ChatGPT, la demanda amplia de habilidades de IA se triplicó hacia mediados de 2024 y las habilidades de IA generativa o LLM pasaron de cero a cerca de 1% de las vacantes, según Eisfeldt y Schubert (2025). Esa señal común luego se traduce de forma desigual por tamaño de firma. Las empresas grandes suelen convertir antes la IA en productividad porque absorben mejor costos de prueba, integración y corrección. Las pymes también adoptan, pero enfrentan más fricciones para llevar pilotos a producción estable por restricciones de talento, infraestructura y gobernanza de datos.</p>
<p>La evidencia de OECD entre 2025 y 2026 refuerza este patrón. La adopción crece en ambos grupos, pero la brecha de escala persiste, en parte porque para muchas empresas pequeñas la prioridad sigue siendo sostener la operación diaria antes que rediseñar procesos o invertir en capacidades tecnológicas. En negocios con base digital mínima, la distancia inicial es todavía mayor. Reducir esa brecha exige acompañamiento humano e institucional, con formación y apoyo de implementación para quienes hoy están más lejos.</p>
<p>Una segunda señal aparece en los precios de mercado. En los días posteriores al lanzamiento de ChatGPT, los sectores más expuestos a IA registraron rendimientos anormales positivos frente a los menos expuestos, también según Eisfeldt y Schubert (2025). La señal económica es clara. Los inversionistas empezaron a descontar beneficios futuros heterogéneos según sector y estructura empresarial. Eso no prueba adopción plena, pero sí una reasignación temprana de expectativas sobre dónde podría concentrarse valor.</p>
<p>La tercera señal está dentro de las empresas, en la organización del trabajo. En cada puesto de finanzas hay tareas repetibles y tareas que exigen criterio. La IA automatiza parte de lo repetible y deja más peso humano en decisiones donde el error cuesta caro. Por eso la pregunta no es si un puesto desaparece, sino qué tareas cambian dentro de ese puesto y qué habilidades laborales pasan a ser decisivas. Eisfeldt, Schubert, Taska y Zhang (2024) precisan este punto al distinguir exposición laboral, exposición del producto y capacidad de datos. Una empresa puede estar muy expuesta por tareas administrativas y poco expuesta por producto, o al revés. Esa heterogeneidad explica por qué firmas del mismo sector reaccionan de forma distinta ante una misma ola tecnológica. La implicación es directa. La unidad relevante de análisis deja de ser el sector en promedio y pasa a ser la arquitectura de tareas y datos de cada firma, porque ahí se define quién convierte la IA en productividad y quién acumula riesgo operativo.</p>
<p>En investigación financiera, el cambio central es que el texto financiero pasa de ser contexto narrativo a insumo empírico medible. Eisfeldt y Schubert (2025) describen este giro como un shock tecnológico sobre la producción de conocimiento. Preguntas antes inviables por costo de lectura, clasificación y síntesis de texto hoy entran en la frontera empírica. Trabajar con corpus masivos de texto ya no es excepcional. El límite se movió desde la capacidad de procesar información hacia la calidad del diseño de medición y la solidez de la inferencia.</p>
<p>Ese cambio metodológico se vuelve tangible en aplicaciones concretas. Con embeddings y clasificación con LLM, la investigación puede convertir miles de reportes corporativos, conferencias de resultados y documentos regulatorios en variables comparables, en lugar de depender de lectura manual caso por caso. RAG permite localizar evidencia relevante en corpus extensos con menos resultados irrelevantes que una búsqueda por palabras. La simulación de agentes, por ejemplo perfiles virtuales de inversionistas, analistas o clientes, ayuda a probar hipótesis antes de desplegar encuestas y experimentos de campo. Esos diseños requieren más tiempo y presupuesto cuando se ejecutan directamente en terreno. El avance no es solo ahorro de tiempo. Es un cambio de escala en lo que puede medirse con rigor en finanzas y, por lo tanto, en el tipo de preguntas que pueden responderse empíricamente.</p>
<p>La incorporación de nuevas clases de datos, en especial texto financiero, amplía la frontera empírica y también eleva las exigencias metodológicas. Con IA generativa, los resultados pueden variar según el modelo, su versión, la forma de la instrucción y las reglas usadas para clasificar o calificar respuestas. Por eso la validación contra referencias humanas, las pruebas de sensibilidad y el registro detallado de decisiones pasan de recomendación técnica a condición de comparabilidad. Cuando la herramienta de medición cambia, la consistencia del procedimiento pasa a ser parte del resultado.</p>
<p>La literatura reciente refuerza este diagnóstico. Calaf y Chiaramonte (2025) documentan una adopción creciente de LLM en investigación económica, y Novy-Marx y Velikov (2025) muestran reducciones sustantivas de costo en tareas de investigación asistida por IA. Desde supervisión financiera y banca central, los reportes del BIS en 2025 observan un patrón similar. La adopción avanza primero en usos de menor complejidad y el cuello de botella aparece al escalar, cuando se vuelven decisivas las capacidades técnicas y los marcos de gobernanza.</p>
<p>En paralelo, es probable que el volumen de investigación aumente con rapidez porque formular hipótesis, contrastarlas y producir resultados cuesta menos tiempo y dinero. Ese aumento, sin embargo, no garantiza calidad. Si evaluación y diseminación se automatizan sin criterios sólidos, el sistema puede volverse más productivo y también más ruidoso. Al mismo tiempo, investigadores consolidados que adopten bien estas herramientas pueden expandir su producción de alta calidad y competir con una oferta mucho mayor de resultados heterogéneos. En ese equilibrio, el criterio humano sigue siendo decisivo para sostener estándares y separar evidencia robusta de resultados aparentes.</p>
<p>La cuestión de fondo no es solo tecnológica. Es una cuestión de capacidad institucional para convertir herramientas nuevas en decisiones mejores, sin perder calidad analítica. En empresas, ese criterio separa adopción superficial de productividad sostenida. En investigación, separa resultados llamativos de evidencia robusta. Con la evidencia disponible a febrero de 2026, esta lectura es sólida. Su vigencia, sin embargo, dependerá de cómo evolucionen las prácticas organizacionales y los estándares metodológicos en los próximos años.</p>
<section id="referencias" class="level2">
<h2 class="anchored" data-anchor-id="referencias">Referencias</h2>
<p>Eisfeldt, Andrea L., y Gregor Schubert (2025). <em>Generative AI and Finance</em>. <em>Annual Review of Financial Economics</em> 17, 363-393. https://doi.org/10.1146/annurev-financial-112923-020503.</p>
<p>Eisfeldt, Andrea L., Gregor Schubert, Bledi Taska y Miao Zhang (2024). <em>Data, Measurement, and Stylized Facts</em> (working paper, SSRN 4436627).</p>
<p>OECD (2025). <em>AI adoption by small and medium-sized enterprises</em>.</p>
<p>OECD (2025). <em>Generative AI and the SME Workforce: New Survey Evidence</em>.</p>
<p>OECD (2026). <em>AI use by individuals surges across the OECD as adoption by firms continues to expand</em>.</p>
<p>Calaf, G. M., y F. M. Chiaramonte (2025). <em>The adoption of Large Language Models in economics research</em>.</p>
<p>Novy-Marx, R., y M. Z. Velikov (2025). <em>AI-Powered (Finance) Scholarship</em>. NBER Working Paper 33363.</p>
<p>Prenio, J. (2025). <em>Starting with the basics: a stocktake of gen AI applications in supervision</em>. BIS FSI Brief No 26.</p>
<p>BIS (2025). <em>The use of artificial intelligence for policy purposes: Report submitted to the G20 Finance Ministers and Central Bank Governors</em>.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>