<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.54">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ai_fin</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="ai_fin_files/libs/clipboard/clipboard.min.js"></script>
<script src="ai_fin_files/libs/quarto-html/quarto.js"></script>
<script src="ai_fin_files/libs/quarto-html/popper.min.js"></script>
<script src="ai_fin_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="ai_fin_files/libs/quarto-html/anchor.min.js"></script>
<link href="ai_fin_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="ai_fin_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="ai_fin_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="ai_fin_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="ai_fin_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">ai_fin</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="ia-en-finanzas-una-perspectiva-desde-la-empresa-y-la-investigación-financiera" class="level1">
<h1>IA en finanzas, una perspectiva desde la empresa y la investigación financiera</h1>
<p><strong>Referencia base</strong> Andrea L. Eisfeldt y Gregor Schubert. <em>Generative AI and Finance</em>. <em>Annual Review of Financial Economics</em> 17 (2025), 363-393. <strong>Última modificación</strong> 2026-02-14 05:36:49 CST.</p>
<p>La IA está cambiando al mismo tiempo la dinámica de las empresas y la investigación en finanzas. Mirar solo uno de esos planos deja una lectura incompleta. En la práctica, la adopción empresarial avanza con ritmos desiguales, mientras la frontera de investigación se expande con herramientas nuevas para medir y analizar.</p>
<p>En el plano empresarial, el avance es desigual. Las empresas grandes suelen convertir antes la IA en productividad y ventaja operativa porque absorben mejor los costos de prueba, corrección e integración. Muchas empresas pequeñas también avanzan, pero en etapas más lentas, con mayores restricciones de talento, infraestructura y datos. Esta lectura describe bien la evidencia actual, pero debe entenderse como una lectura condicionada al estado presente de la tecnología y de su adopción.</p>
<p>Eisfeldt y Schubert (2025) muestran este proceso en datos concretos. Tras el lanzamiento de ChatGPT, la demanda amplia por habilidades de IA se triplicó hacia mediados de 2024, y la demanda por habilidades ligadas a IA generativa o LLM pasó de cero a cerca de 1% de todas las vacantes. Esa transición en contrataciones indica que las empresas están reconfigurando capacidades internas para operar con esta tecnología.</p>
<p>En el mismo período, los mercados también reaccionaron. Eisfeldt y Schubert (2025) encuentran que, en los días posteriores al lanzamiento, los sectores más expuestos a IA tuvieron rendimientos anormales positivos frente a los menos expuestos. La implicación es económica. Los inversionistas comenzaron a descontar que la IA podía elevar beneficios futuros de manera diferencial según sector y tipo de empresa. Esta señal todavía no equivale a adopción plena, pero sí revela un cambio de expectativas sobre quién podría capturar valor antes.</p>
<p>Ese punto se entiende mejor cuando se observa el trabajo dentro de las organizaciones. En finanzas, los puestos combinan tareas distintas. Algunas son repetitivas y codificables, otras dependen de juicio, negociación, interpretación contextual y relación con clientes. Lo determinante es la composición de tareas dentro de cada rol. Allí aparece el efecto real de la IA. Automatiza partes estandarizables, reorganiza flujos y desplaza el valor humano hacia decisiones donde importa interpretar contexto, priorizar riesgos y asumir responsabilidad. En esa lectura, el criterio humano cambia de lugar y se vuelve más visible donde una mala decisión tiene costos altos.</p>
<p>Eisfeldt, Schubert, Taska y Zhang (2024) refuerzan esta lectura con un enfoque más granular. En este contexto, exposición significa qué tan directamente una tarea o una empresa puede verse afectada por la IA generativa en su operación, sus productos o sus costos. Su aporte muestra los límites de un promedio único para toda la empresa o todo el sector. Conviene distinguir entre exposición laboral, asociada a tareas del trabajo, exposición del producto, asociada a lo que la empresa vende, y capacidad de datos de cada organización. Ese matiz explica por qué empresas del mismo sector reaccionan distinto frente a la misma tecnología.</p>
<p>La evidencia más reciente de OECD para 2025-2026 va en la misma dirección. El uso empresarial de IA crece, pero las brechas por tamaño de empresa persisten. En pymes, el problema central suele ser el costo de llevar casos de uso a producción estable. En empresas grandes, esos costos fijos se reparten mejor y las pruebas operativas tienen mayor probabilidad de convertirse en procesos permanentes. Por eso el avance agregado puede coexistir con diferencias de desempeño cada vez más visibles entre empresas.</p>
<p>En investigación en finanzas, la transformación es igual de profunda. Eisfeldt y Schubert (2025) describen este momento como un shock tecnológico sobre la producción de conocimiento. Antes, muchas preguntas quedaban fuera porque leer, clasificar y sintetizar texto y datos a gran escala exigía costos de tiempo y dinero muy altos. Ahora ese límite se movió. Ya es posible trabajar con corpus masivos de lenguaje natural y convertirlos en insumos empíricos en tiempos mucho menores. También en investigación, la IA desplaza trabajo operativo y vuelve más central el juicio sobre diseño, medición e interpretación.</p>
<p>Esta apertura de frontera conecta con lo que ya aparece en la dinámica empresarial. Si en la empresa el valor se mueve hacia tareas con más juicio, en investigación ocurre algo análogo. Los modelos absorben una parte creciente del trabajo de extracción, clasificación y síntesis, y liberan tiempo para diseño, inferencia y evaluación crítica.</p>
<p>Los métodos que destacan Eisfeldt y Schubert (2025) importan por lo que habilitan en problemas concretos de finanzas. Los embeddings permiten medir significado en texto financiero sin depender de listas rígidas de palabras, algo clave cuando el tono o la intención cambian con el contexto. La clasificación con LLM permite construir variables sobre miles de documentos que antes no podían procesarse de forma consistente. En términos financieros, esto impacta en cómo se mide riesgo, cómo se extraen señales de conferencias de resultados y reportes regulatorios, y cómo se construyen indicadores para valoración y decisiones de portafolio.</p>
<p>RAG permite trabajar con corpus enormes sin perder foco en evidencia pertinente. El salto frente a procesamiento tradicional no está solo en potencia de cómputo. Está en combinar recuperación semántica y razonamiento contextual sobre fragmentos relevantes, con menos ruido y mediciones más precisas en documentos extensos y heterogéneos. En finanzas esto importa porque gran parte de la información útil está dispersa en textos largos, reportes regulatorios, comunicaciones corporativas y documentos legales. En ese entorno, una búsqueda por palabras puede recuperar frases similares pero irrelevantes para la pregunta económica. La simulación de agentes permite probar hipótesis y diseños antes de desplegar encuestas costosas. La novedad no es solo hacer lo mismo más rápido, sino volver factibles preguntas que antes quedaban fuera por límites de diseño y procesamiento.</p>
<p>El avance vuelve la exigencia metodológica más específica. A diferencia de herramientas computacionales tradicionales, los LLM introducen una fuente nueva de variación. El resultado puede cambiar de forma sustantiva con el modelo elegido, su versión, el orden del prompt o la forma de definir una rúbrica de puntuación. Por eso Eisfeldt y Schubert (2025) enfatizan validación contra referencias humanas, pruebas de sensibilidad y documentación detallada de diseño. Con IA generativa, la propia medición puede moverse si no se fija con cuidado el procedimiento. En investigación, la contribución humana decisiva aparece en ese tramo, fijar criterios, auditar salidas y sostener comparabilidad.</p>
<p>La literatura reciente confirma esta trayectoria. Calaf y Chiaramonte (2025) muestran adopción creciente de LLM en investigación económica. Novy-Marx y Velikov (2025) documentan la magnitud de la reducción de costos en tareas de investigación asistida por IA. Los reportes del BIS de 2025 aportan otra pieza relevante desde la supervisión financiera, en el trabajo de bancos centrales y reguladores que monitorean riesgo sistémico y cumplimiento prudencial. Allí aparece un patrón compatible con esta lectura, adopción en expansión, entrada por usos de menor complejidad y dificultades al escalar cuando faltan capacidades técnicas y de gobernanza.</p>
<p>En conjunto, el punto es claro. La IA amplió de forma tangible lo que las empresas pueden hacer y lo que la investigación en finanzas puede medir. Ese cambio ya se observa en contratación, expectativas de mercado, organización del trabajo y forma de producir evidencia empírica.</p>
<p>La cuestión central hacia adelante es cómo se distribuyen beneficios y riesgos en una etapa de adopción desigual. También importa sostener calidad analítica cuando la producción de evidencia se acelera y las herramientas de medición pueden variar con el diseño. En este contexto, empresa e investigación forman parte de un mismo problema de capacidad, criterio y responsabilidad. Esta lectura es sólida con la evidencia disponible hoy y debe mantenerse abierta a revisión a medida que cambien capacidades tecnológicas, prácticas organizacionales y estándares metodológicos.</p>
<section id="referencias" class="level2">
<h2 class="anchored" data-anchor-id="referencias">Referencias</h2>
<p>Eisfeldt, Andrea L., y Gregor Schubert (2025). <em>Generative AI and Finance</em>. <em>Annual Review of Financial Economics</em> 17, 363-393. https://doi.org/10.1146/annurev-financial-110923-023628. Eisfeldt, Andrea L., Gregor Schubert, Bledi Taska y Miao Zhang (2024). <em>Data, Measurement, and Stylized Facts</em> (working paper, SSRN 4436627). OECD (2025). <em>AI adoption by small and medium-sized enterprises</em>. OECD (2025). <em>Generative AI and the SME Workforce: New Survey Evidence</em>. OECD (2026). <em>AI use by individuals surges across the OECD as adoption by firms continues to expand</em>. Calaf, G. M., y F. M. Chiaramonte (2025). <em>The adoption of Large Language Models in economics research</em>. Novy-Marx, R., y M. Z. Velikov (2025). <em>AI-Powered (Finance) Scholarship</em>. NBER Working Paper 33363. Prenio, J. (2025). <em>Starting with the basics: a stocktake of gen AI applications in supervision</em>. BIS FSI Brief No 26. BIS (2025). <em>The use of artificial intelligence for policy purposes: Report submitted to the G20 Finance Ministers and Central Bank Governors</em>.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>