<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.54">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ia_edu</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="ia_edu_files/libs/clipboard/clipboard.min.js"></script>
<script src="ia_edu_files/libs/quarto-html/quarto.js"></script>
<script src="ia_edu_files/libs/quarto-html/popper.min.js"></script>
<script src="ia_edu_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="ia_edu_files/libs/quarto-html/anchor.min.js"></script>
<link href="ia_edu_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="ia_edu_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="ia_edu_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="ia_edu_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="ia_edu_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">ia_edu</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="ia-en-educación-superior-criterio-velocidad-y-aprendizaje-real" class="level1">
<h1>IA en educación superior, criterio, velocidad y aprendizaje real</h1>
<p><strong>Borrador</strong> versión inicial para revisión de estilo y estructura.</p>
<p>La IA cambió de forma simultánea el trabajo académico y el trabajo profesional que intentamos enseñar en educación superior. Esa simultaneidad importa en escuelas de negocio, donde formar a una persona significa prepararla para analizar información incompleta, decidir bajo presión y justificar decisiones frente a otros. En ese entorno, la IA no es solo una herramienta de productividad. También es una fuerza que altera qué significa comprender algo y qué significa demostrar que se comprende.</p>
<p>La discusión suele partir de extremos. Un extremo asume que la IA resolverá casi todo y que aprender contenidos en profundidad será cada vez menos necesario. El otro extremo asume que la IA degradará inevitablemente la formación y volverá superficial cualquier proceso educativo. Ninguna de las dos lecturas ayuda demasiado. La experiencia en aula sugiere un diagnóstico más útil. La IA puede acelerar la comprensión o acelerar la ilusión de comprensión.</p>
<p>Esa diferencia se vuelve visible en el tipo de uso. Cuando una persona usa IA para obtener un resultado rápido y detenerse ahí, puede producir entregables ordenados, bien redactados y aparentemente sólidos sin dominar metodología, conceptos o límites. El resultado luce competente, pero la competencia real sigue ausente. Aquí aparece un riesgo que merece nombre propio. Un analfabetismo funcional asistido por IA, donde se ejecutan tareas con apariencia de control sin entender realmente qué se hizo.</p>
<p>El problema es más delicado porque la salida de la IA suele ser convincente en forma y tono. La respuesta llega rápido, con estructura y seguridad retórica. Esa combinación puede inducir sobreconfianza. No hace falta mala fe para caer en eso. Basta con un entorno que premia velocidad y entrega inmediata. La rapidez, por sí misma, no es el problema. El riesgo aparece cuando la rapidez sustituye la fricción cognitiva que exige aprender.</p>
<p>También existe la otra cara, y es la que justifica impulsar la IA en educación superior. Hoy es posible hacer cosas que antes eran inviables por tiempo, costo o escala. Un estudiante puede explorar más hipótesis, comparar más enfoques, iterar más rápido y llegar a proyectos más ambiciosos en menos semanas. Un docente puede diseñar experiencias de aprendizaje más ricas y con mayor cercanía a problemas reales. El salto de frontera es claro. Pero esa frontera solo se vuelve útil cuando hay criterio para formular preguntas y validar respuestas.</p>
<p>Por eso, en este contexto, el conocimiento de base del área no pierde valor. Cambia su función. Sin comprensión de negocio, método y datos, ni siquiera se sabe qué pedirle a la IA, qué salida es relevante y qué salida es ruido. En programación pasa algo parecido. Memorizar sintaxis pesa menos que antes. Pesa más definir el problema correcto, estructurar datos, elegir técnica y auditar resultados. El valor se desplaza desde recordar comandos hacia diseñar decisiones.</p>
<p>Esta reasignación de valor no es completamente nueva en la historia de la tecnología educativa. Con internet se temió que nadie volvería a pensar porque la información estaría siempre disponible. Con calculadoras se temió que la matemática se vaciaría de contenido. El tiempo mostró algo más matizado. Las herramientas no eliminan la necesidad de comprender. Cambian qué habilidades se vuelven centrales para comprender y decidir bien.</p>
<p>La novedad de la IA generativa está en la magnitud y en el tipo de delegación posible. Antes delegábamos búsqueda, cálculo o edición. Ahora también delegamos redacción argumentativa, clasificación semántica y parte de la exploración conceptual inicial. Esa delegación amplía productividad, pero también mueve el punto crítico de calidad. Ya no basta con revisar el resultado final. Hay que evaluar trazabilidad, criterios de elección y capacidad de defensa de lo que se presentó.</p>
<p>Aquí la escuela de negocio tiene una oportunidad concreta. Cambiar la evaluación para alinear incentivos con aprendizaje real. Si la evaluación premia solo el entregable final, la IA se vuelve atajo natural. Si la evaluación premia comprensión defendible, la IA se vuelve asistente de alto valor. El cambio más importante puede estar menos en la herramienta y más en el sistema de evaluación.</p>
<p>Ese rediseño no requiere abandonar la producción de resultados. Requiere complementarla. Menos peso al documento aislado y más peso a defensa oral en vivo, preguntas cruzadas, explicación de supuestos, justificación metodológica y claridad sobre qué parte del trabajo fue delegada y por qué. En términos prácticos, importa distinguir entre quien usa una caja negra con criterio y quien la usa sin entenderla. También importa evaluar si la persona reconoce límites, riesgos de error y condiciones bajo las cuales su conclusión dejaría de ser válida.</p>
<p>Esta lógica también protege el uso responsable de la IA. Cuando el estudiante sabe que tendrá que explicar decisiones, argumentar en tiempo real y responder objeciones, prepara el trabajo de otra forma. La herramienta deja de ser sustituto del pensamiento y pasa a ser amplificador del pensamiento. El objetivo no es prohibir la IA ni romantizar el esfuerzo manual. El objetivo es que velocidad y profundidad no se vuelvan incompatibles en el diseño pedagógico.</p>
<p>En ese marco, el rol docente gana relevancia. Enseñar ya no se reduce a transmitir contenido. Incluye entrenar juicio sobre calidad de evidencia, robustez de inferencias y límites de automatización. Incluye, además, desarrollar una alfabetización en IA que no se confunda con destreza superficial de prompting. Usar IA bien no es obtener una respuesta fluida. Es saber cuándo confiar, cuándo dudar, qué contrastar y cómo justificar.</p>
<p>La discusión de fondo, entonces, no separa tecnología y pedagogía. Las integra. La calidad de adopción depende de la herramienta y del diseño institucional que la rodea. Por eso el debate útil para escuelas de negocio no es usar IA o no usar IA. Es cómo usarla para construir competencia real en lugar de apariencia de competencia.</p>
<p>Si ese criterio se mantiene, la IA puede elevar la ambición de la educación superior en vez de degradarla. Puede llevar a proyectos más complejos, preguntas más interesantes y ciclos de aprendizaje más rápidos sin perder rigor. Si ese criterio se pierde, la misma tecnología puede producir una cultura de resultados impecables en forma y vacíos en comprensión. La diferencia entre ambos escenarios no está escrita en la herramienta. Está en las expectativas, en la evaluación y en el tipo de responsabilidad intelectual que la institución decide exigir.</p>
<section id="referencias-de-apoyo-conceptual" class="level2">
<h2 class="anchored" data-anchor-id="referencias-de-apoyo-conceptual">Referencias de apoyo conceptual</h2>
<p>AI literacy, metacognición, aprendizaje autorregulado, cognitive offloading, automation bias, desirable difficulties, deskilling y reskilling, capacidades dinámicas y absorptive capacity.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>