<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Martin">

<title>Portafolio y vida, asignar pesos bajo incertidumbre</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="port_vida_files/libs/clipboard/clipboard.min.js"></script>
<script src="port_vida_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="port_vida_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="port_vida_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="port_vida_files/libs/quarto-html/popper.min.js"></script>
<script src="port_vida_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="port_vida_files/libs/quarto-html/anchor.min.js"></script>
<link href="port_vida_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="port_vida_files/libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="port_vida_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="port_vida_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="port_vida_files/libs/bootstrap/bootstrap-a3d08eff9b35980c3ade067cc1320f06.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Portafolio y vida, asignar pesos bajo incertidumbre</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Martin </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p>Una persona puede vivir con poco y conservar equilibrio, mientras otra puede tener mucho y vivir desbordada. En inversión ocurre algo parecido. Dos gestores con recursos comparables pueden terminar en resultados opuestos. La diferencia suele estar en cómo distribuyen pesos. En finanzas, entre activos. En la vida, entre dimensiones como trabajo, vínculos, salud, propósito y tiempo. Esos pesos son prioridades, y su ajuste bajo incertidumbre termina moldeando la trayectoria más que las condiciones iniciales. No se trata de reducir la vida a un modelo financiero, sino de usar esa lógica para pensar mejor cómo ordenamos prioridades.</p>
<p>Un portafolio no se define solo por cuánto capital tiene, sino por cómo distribuye exposición y por cómo corrige desbalances cuando el contexto cambia. La vida tampoco se define solo por lo que a una persona le ocurre, sino por cómo lo jerarquiza y por el orden de valores con que organiza sus prioridades cuando cambian el tiempo, la edad o las restricciones.</p>
<p>En gestión de carteras, este punto es elemental. Asignar pesos no es elegir una vez y olvidarlo. Es decidir bajo restricciones, con información incompleta y con objetivos que pueden entrar en tensión entre sí. Quien privilegia estabilidad acepta renunciar a parte del retorno potencial. Quien privilegia crecimiento acepta mayor volatilidad y mayor probabilidad de pérdidas transitorias. El centro del problema no es eliminar el riesgo, sino decidir qué riesgos vale la pena asumir y cuáles exceden la capacidad real de sostenerlos.</p>
<p>Algo equivalente ocurre fuera de los mercados. Una persona también decide, muchas veces sin nombrarlo, cuánto peso asigna a cada dimensión de su experiencia. Puede concentrar su energía en una pérdida reciente y leer el resto de su vida a través de esa única variable. Puede, en cambio, reconocer el daño sin convertirlo en criterio absoluto para interpretar todo. Puede invertir atención en el corto plazo de la urgencia diaria o reservar una parte para decisiones de largo plazo que no rinden hoy, pero definen el rumbo de mañana. Ninguna de esas decisiones es neutral. Todas tienen costo de oportunidad.</p>
<p>La analogía se vuelve más clara en ejemplos simples. Una asignación 1/N, donde todo recibe el mismo peso, puede verse como una vida sin jerarquías reales, una administración indiferenciada de lo importante y lo accesorio. Una cartera cargada hacia activos de riesgo se parece a una vida que privilegia intensidad y posibilidad de saltos grandes, con la contracara de mayor exposición al error. Una cartera predominantemente conservadora se parece a una vida orientada a preservar estabilidad, aunque eso limite algunas oportunidades de transformación. Incluso el apalancamiento tiene su espejo vital. Vivir por encima de la propia capacidad de sostén, emocional o material, puede acelerar logros puntuales y también amplificar quiebres cuando el entorno gira en contra.</p>
<p>El rebalanceo, por eso, no es un detalle técnico ni en finanzas ni en la vida. En mercados, rebalancear es corregir una deriva de pesos que ya no representa la estrategia original o la tolerancia al riesgo actual. En la vida, rebalancear es revisar prioridades cuando la estructura interna cambió, cuando una crisis alteró recursos disponibles o cuando la experiencia mostró que ciertos compromisos estaban sobreponderados. No es una señal de incoherencia. Es una práctica de continuidad inteligente.</p>
<p>La experiencia modifica de forma relevante esa capacidad de ajuste. Un gestor con poca práctica suele confundir ruido con señal, reaccionar tarde o sobrerreaccionar, y tomar decisiones dominadas por el ciclo emocional del mercado. Un gestor experimentado no es infalible, pero reconoce mejor los límites del modelo, anticipa escenarios de tensión y evita concentraciones que no puede defender cuando cambian las condiciones. En la vida, la maduración opera de manera parecida. La juventud puede sobreponderar lo inmediato y subponderar consecuencias acumulativas. Con el tiempo, muchas personas aprenden a distinguir mejor entre lo urgente y lo importante, entre lo que hiere hoy y lo que define una trayectoria.</p>
<p>Este punto se vuelve especialmente visible en crisis. En mercados, las crisis comprimen horizontes y empujan decisiones bajo presión, justo cuando más se necesitaría claridad de marco. En la vida pasa lo mismo. El problema no es sentir miedo, cansancio o angustia en momentos límite. El problema es permitir que ese estado temporal colonice toda la asignación de peso, hasta convertir cada evento en confirmación de una única lectura negativa. Una cartera concentrada en una sola fuente de riesgo queda expuesta a daño desproporcionado. Una vida concentrada en una sola herida queda expuesta a una distorsión equivalente.</p>
<p>Por eso resultan admirables ciertas trayectorias que, en condiciones objetivamente desfavorables, sostienen una forma de alegría, gratitud o sentido. No porque nieguen el dolor ni porque vivan en ilusión, sino porque asignan un peso proporcionado a lo que les toca atravesar. Reconocen la pérdida sin entregarle soberanía total sobre su interpretación del mundo. Del otro lado, también existen casos inversos. Personas con condiciones favorables que magnifican fricciones menores, sobreponderan lo negativo y subponderan recursos reales disponibles. El contraste no se explica solo por dotación inicial. Se explica, en parte, por criterio de ponderación.</p>
<p>Ese criterio no surge de manera espontánea y permanente. En finanzas se entrena con método, disciplina y revisión sistemática de errores. En la vida también requiere capacidades concretas. Juicio para distinguir lo central de lo accesorio. Estabilidad emocional para no decidir siempre desde el pico afectivo del momento. Educación para reconocer sesgos propios. Algún marco de sentido, filosófico o espiritual, que permita ordenar prioridades cuando la evidencia del día no alcanza. Hablar de estas capacidades no moraliza el problema. Lo vuelve practicable.</p>
<p>También conviene reconocer el límite de la comparación. Un portafolio puede optimizarse con funciones objetivo relativamente claras y con métricas estables de riesgo y retorno. La vida incluye dimensiones que no entran limpio en ese lenguaje, como dignidad, amor, duelo, deber o pertenencia. Por eso la analogía vale como herramienta de pensamiento y no como teoría total de la experiencia humana. Sirve para iluminar una parte de la decisión, no para capturarla completa.</p>
<p>Aun con ese límite, la intuición central se mantiene firme. Vivir implica asignar pesos de manera continua, bajo condiciones que rara vez son ideales. No elegimos todos los eventos, pero sí participamos en la ponderación que les damos. Esa ponderación afecta qué vemos, qué dejamos fuera, qué preservamos y qué sacrificamos. En términos financieros, define perfil y trayectoria. En términos humanos, define carácter y forma de estar en el mundo.</p>
<p>Una buena vida no es una vida sin volatilidad. Del mismo modo, una buena cartera no es una cartera sin riesgo. La cuestión decisiva es otra. Si la asignación de pesos que sostenemos hoy nos permite atravesar pérdidas sin quedar capturados por ellas, aprovechar oportunidades sin negarnos a los límites, y mantener un horizonte que no se reduzca al ruido del presente. Aprender a ponderar mejor, entonces, no es una técnica fría. Es una forma concreta de sabiduría práctica.</p>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>