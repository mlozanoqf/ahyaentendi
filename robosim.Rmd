---
title: "\\textbf{Un robo-trader simple.}"
subtitle: "Construcción y evaluación de su desempeño."
author: "Dr. Martín Lozano \\texttt{https://mlozanoqf.github.io/}"
date: "`r gsub('a\\. m\\.', 'a.m.', gsub('p\\. m\\.', 'p.m.', format(Sys.time(), '%d de %B de %Y, %I:%M %p')))`"
output:
  pdf_document:
    latex_engine: xelatex
    number_sections: true
    highlight: tango
header-includes:
  - \usepackage{xcolor}
  - \usepackage{fvextra}
  - |
      \DefineVerbatimEnvironment{Highlighting}{Verbatim}{
        breaklines,
        commandchars=\\\{\},
        numbers=left,
        numbersep=8pt,
        fontsize=\small,
        firstnumber=1,
        xleftmargin=1.5em,
        frame=none
      }
      % ← Estilo de los números de línea (más visibles)
      \renewcommand{\theFancyVerbLine}{\textcolor{black}{\bfseries\small\arabic{FancyVerbLine}}}
  - \usepackage{amssymb}
  - \usepackage{amsmath}
---

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

tabla <- matrix(
  c("$\\times$", "$\\checkmark$", "$\\times$",
    "$\\times$", "$\\checkmark$", "$\\times$",
    "$\\times$", "$\\checkmark$", "$\\times$"),
  nrow = 3, byrow = TRUE
)
colnames(tabla) <- c("Fundamental", "Intermedio", "Especializado")
rownames(tabla) <- c("Finanzas", "Estadística", "R")

kable(tabla, escape = FALSE, align = c("c","c","c"))

```





```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  class.source = "numberLines",   # activa numeración en todos los chunks con echo=TRUE
  Sys.setlocale("LC_TIME", "es_ES.UTF-8")
)
```

\newpage
\Large 

# Introducción.

\begin{itemize}
  \item Este documento ilustra la construcción, implementación y evaluación de un robo-trader sencillo para AAPL.
  \item La sencillez radica en que la señal de trading se basa únicamente en cruces del precio de cierre con un promedio móvil simple de 3 días (MA3), generando órdenes buy/sell.
  \item El desempeño se compara contra benchmarks y contra estrategias alternativas.
  \item Se reportan ganancia simple, número de operaciones y se documenta el proceso mediante gráficos y bitácoras de operaciones.
  \end{itemize}
\newpage

# Paquetes.

```{r}
library(tidyquant)
library(dplyr)
library(lubridate)
library(ggplot2)
library(tidyr)
library(purrr)
library(knitr)
```

\newpage

# Inicialización 1.

Funciones que vamos a usar en todo el documento.

```{r}
raw_prices <- tq_get("AAPL", from = "2024-11-01", to = "2025-12-31") |>
  arrange(date)

prices_ma3 <- raw_prices |>
  tq_mutate(select = close, mutate_fun = SMA, n = 3, col_rename = "ma3")

start_date <- prices_ma3 |>
  filter(date >= as.Date("2025-01-02"), !is.na(ma3)) |>
  slice_head(n = 1) |>
  pull(date)

final_date <- prices_ma3 |>
  filter(date <= as.Date("2025-12-19")) |>
  slice_tail(n = 1) |>
  pull(date)

rt_data <- prices_ma3 |>
  filter(date >= start_date - days(1), date <= final_date) |>
  mutate(sign_diff = sign(close - ma3),
         lag_sign  = lag(sign_diff),
         cross     = !is.na(sign_diff) & !is.na(lag_sign) & sign_diff != lag_sign,
         signal    = case_when(
           cross & sign_diff > lag_sign ~ "buy",
           cross & sign_diff < lag_sign ~ "sell",
           TRUE ~ "hold"))

signals_rt <- rt_data |>
  filter(signal %in% c("buy", "sell"), date >= start_date) |>
  transmute(date, signal, price = close) |>
  arrange(date)

signals_eval <- bind_rows(signals_rt,
    tibble(date = final_date, signal = "final_close", 
           price = rt_data$close[rt_data$date == final_date][1])) |> 
  arrange(date)

signal_outcomes <- signals_eval |>
  mutate(next_price = lead(price), next_signal = lead(signal)) |>
  filter(signal %in% c("buy", "sell")) |>
  mutate(trade_pnl = if_else(signal == "buy", next_price - price, price - next_price),
         correct = trade_pnl > 0)

signals_omniscient <- signal_outcomes |> filter(correct) |>
  select(date, signal, price)
signals_dumb <- signal_outcomes |> filter(!correct) |>
  select(date, signal, price)
```

\newpage

# Inicialización 2.

Funciones que vamos a usar en todo el documento.

```{r}
# Helpers
simulate_pnl <- function(signals_df, final_price) {
  pnl <- 0; position <- "flat"; entry <- NA_real_
  for (i in seq_len(nrow(signals_df))) {
    sig <- signals_df$signal[i]; px <- signals_df$price[i]
    if (position == "flat") {
      position <- if (sig == "buy") "long" else "short"; entry <- px
      } else if (sig == "buy" && position == "short") {
        pnl <- pnl + (entry - px); position <- "long"; entry <- px
      } else if (sig == "sell" && position == "long") {
        pnl <- pnl + (px - entry); position <- "short"; entry <- px
      } else if (sig == position) {
        pnl <- pnl + if (position == "long") (px - entry) else (entry - px)
        entry <- px
      }
    }
    if (!is.na(final_price) && position != "flat") {
      pnl <- pnl + if (position == "long") (final_price - entry) else (entry - final_price)}
    pnl}

make_bitacora <- function(signals_df, final_date, final_price) {
  signals_eval <- bind_rows(signals_df |> arrange(date),
                              tibble(date = final_date, signal = "final_close", 
                                     price = final_price)) |>
    arrange(date)
  position <- "flat"; entry <- NA_real_; pnl_acum <- 0; logs <- list()
  for (i in seq_len(nrow(signals_eval))) {
    sig <- signals_eval$signal[i]; px <- signals_eval$price[i]
    if (position == "flat") {
      if (sig %in% c("buy", "sell")) {
        flujo <- if (sig == "buy") -px else px
        logs[[length(logs) + 1]] <- tibble(date = signals_eval$date[i], 'acción' = sig,
                                             price = px, flujo = flujo,
                                             PnL = 0, PnL_acum = pnl_acum)
          position <- if (sig == "buy") "long" else "short"; entry <- px
        }
      } else if (sig %in% c("buy", "sell", "final_close")) {
        pnl <- if (position == "long") px - entry else entry - px
        flujo <- if (sig == "buy") -px else if (sig == "sell") px else 0
        pnl_acum <- pnl_acum + pnl
        logs[[length(logs) + 1]] <- tibble(date = signals_eval$date[i], 'acción' = sig,
                                           price = px, flujo = flujo,
                                           PnL = pnl, PnL_acum = pnl_acum)
        if (sig == "final_close") { position <- "flat"; entry <- NA_real_ }
        else { position <- if (sig == "buy") "long" else "short"; entry <- px }
      }
    }
    bind_rows(logs)
  }

show_head_tail <- \(df, n = 5) bind_rows(slice_head(df, n = n), slice_tail(df, n = n))
```

\newpage

# Serie de tiempo.

El escenario en el que evaluaremos al robo-trader.

```{r}
last15_2024 <- prices_ma3 |>
  filter(year(date) == 2024) |>
  arrange(date) |>
  tail(15)

start_date_plot <- min(last15_2024$date)
end_date  <- as.Date("2025-12-19")

aapl_window <- prices_ma3 |>
  filter(date >= start_date_plot, date <= end_date)

ggplot(aapl_window, aes(x = date, y = close)) +
  geom_line(color = "blue", linewidth = 0.9) +
  geom_vline(xintercept = as.Date("2025-01-02"), linetype = "dashed", color = "gray40") +
  labs(title = "Apple (AAPL) - Precios de cierre.",
       subtitle = paste("Desde", start_date_plot, "hasta", end_date),
       x = "Fecha", y = "Precio de cierre (USD)") +
  theme_minimal(base_size = 12)
```

\newpage

# Benchmarks.

Hay dos benchmarks naturales que surgen. El primero es buy and hold, que sería una estrategia que no requiere el seguimiento de un criterio inteligente. El segundo es uno tramposo en donde vemos el futuro, vendemos en corto, realizamos la ganancia en el precio más bajo, compramos y vendemos al final, lo que daría una ganancia alta, posiblemente una ganancia máxima. 

```{r}
first_2025 <- prices_ma3 |> filter(date >= as.Date("2025-01-01")) |>
  slice_head(n = 1)
buy_hold_buy_date <- first_2025$date
buy_hold_buy_px <- first_2025$close

sell_12dec <- prices_ma3 |> filter(date <= as.Date("2025-12-12")) |>
  slice_tail(n = 1)
buy_hold_sell_date <- sell_12dec$date
buy_hold_sell_px <- sell_12dec$close

min_row <- prices_ma3 |>
  filter(date >= as.Date("2025-01-01"), date <= as.Date("2025-12-19")) |>
  slice_min(close, n = 1, with_ties = FALSE)
min_date <- min_row$date
min_px <- min_row$close

final_row <- prices_ma3 |> filter(date <= as.Date("2025-12-19")) |>
  slice_tail(n = 1)
final_date <- final_row$date
final_px <- final_row$close

buy_hold_gain <- buy_hold_sell_px - buy_hold_buy_px
trampa_gain <- (buy_hold_buy_px - min_px) + (final_px - min_px)

strategies <- tibble(estrategia = c("Buy & hold", "Trampa"),
  ganancia_simple = c(buy_hold_gain, trampa_gain))

strategies
```

\newpage

# La trampa.

Este es el detalle de la estrategia tramposa. 

```{r}
P0   <- buy_hold_buy_px
Pmin <- min_px
Pend <- final_px

tramo_corto <- P0 - Pmin
tramo_largo <- Pend - Pmin
gan_trampa  <- tramo_corto + tramo_largo

tibble(P0, Pmin, Pend,
       tramo_corto = tramo_corto,
       tramo_largo = tramo_largo,
       ganancia_trampa = gan_trampa) |> 
  mutate(across(everything(), ~ round(.x, 2))) |> 
  kable()
```

Precios relevantes: $P_0$ = 243.85 (cierre inicial), $P_{min}$ = 172.42 (mínimo anual), $P_{end}$ = 273.67 (cierre final). 

Descripción de la estrategia: Abres corto al primer cierre de 2025, vendiendo a 243.85 y comprando a 172.42, el tramo corto gana 243.85 − 172.42 = 71.43. Compras inmediatamente en el mínimo de 172.42 y vendes al cierre final de 273.67, el tramo largo gana 273.67 − 172.42 = 101.25. 

La ganancia total de la estrategia trampa es: 71.43 + 101.25 = 172.68.

\newpage

# Definición de las señales de compra y venta.

El robo-trader usa un promedio móvil simple SMA de 3 días $\text{SMA3}_t$ sobre el precio de cierre $P_t$:
$\text{SMA3}_t = \frac{1}{3}\big(P_t + P_{t-1} + P_{t-2}\big)$,
definido cuando existen los tres cierres necesarios; por ello, los primeros 2 días resultan en `NA`.

Definimos $d_t = P_t - \text{SMA3}_t$.

La $\text{SMA3}_t$ funciona como un “nivel de referencia” de corto plazo. El signo de $d_t$ indica en qué lado está el precio respecto a ese nivel:

- Si $d_t > 0$, el precio está por encima de su promedio reciente. Se puede interpretar como un sesgo alcista de corto plazo.
- Si $d_t < 0$, el precio está por debajo de su promedio reciente. Se puede interpretar como un sesgo bajista de corto plazo.

El robot opera únicamente cuando detecta un *cambio de régimen*: es decir, cuando el precio pasa de estar consistentemente por debajo a estar por encima (o viceversa). Por eso se usa el cruce (cambio de signo) y no solo la condición “estar arriba/abajo”.

- Señal de compra en $t$: ocurre si $d_{t-1} < 0$ y $d_t > 0$. El precio cruza desde abajo hacia arriba la SMA3. Representa un cambio de sesgo a alcista.
- Señal de venta en $t$: ocurre si $d_{t-1} > 0$ y $d_t < 0$. El precio cruza desde arriba hacia abajo la SMA3. Representa un cambio de sesgo a bajista.
- Si no hay cruce (incluyendo el caso $d_t = 0$), no hay señal y se mantiene “hold”.

\newpage

# Supuestos operativos del robo-trader.

- Se evalúa la señal una vez por día.

- El robot siempre mantiene una posición. Un `sell` cierra un largo y abre un corto; un `buy` cierra un corto (buy-to-cover) y abre un largo. No existe estado “cash” entre señales.

- Se ignoran comisiones, bid-ask spread, slippage y costos de préstamo/financiamiento.

- No hay gestión de riesgo, los cambios de posición ocurren únicamente por cruces de SMA3.

- Al término del periodo se fuerza un `final_close` para cerrar cualquier posición abierta al último precio de cierre.

\newpage

# Visualización del promedio móvil.

```{r}
ggplot(prices_ma3, aes(date)) +
  geom_line(aes(y = close, color = "Cierre"), linewidth = 1.5, alpha = 0.5) +
  geom_line(aes(y = ma3,   color = "MA 3 días"), linewidth = 0.7, na.rm = TRUE) +
  geom_vline(xintercept = as.Date("2025-01-02"), linetype = "dashed", color = "gray40") +
  scale_color_manual(name = "Serie",
                       values = c("Cierre" = "blue", "MA 3 días" = "red")) +
  labs(title = "AAPL: Cierre vs. Promedio Móvil 3 días.",
       x = "Fecha", y = "Precio (USD)") +
  theme_minimal(base_size = 12)
```

\newpage

# Promedio móvil, zoom.

```{r}
# Ventana del zoom
start_zoom <- as.Date("2025-11-21")
end_zoom   <- as.Date("2025-12-19")

# Señales buy/sell por cruce precio vs SMA3
signals_short <- prices_ma3 |>
  mutate(sign_diff = sign(close - ma3), lag_sign  = lag(sign_diff),
         cross = !is.na(sign_diff) & !is.na(lag_sign) & sign_diff != lag_sign,
         signal    = case_when(
           cross & sign_diff > lag_sign ~ "buy",
           cross & sign_diff < lag_sign ~ "sell",
           TRUE ~ NA_character_)) |>
  filter(date >= start_zoom, date <= end_zoom, !is.na(signal)) |>
  transmute(date, signal, price = close)

# Serie y etiquetas B/S
aapl_ma_short <- prices_ma3 |>
  filter(date >= start_zoom, date <= end_zoom)
  
ggplot(aapl_ma_short, aes(date)) +
  geom_line(aes(y = close, color = "Cierre"), linewidth = 1) +
  geom_line(aes(y = ma3,   color = "SMA 3 días"), linewidth = 1, na.rm = TRUE) +
  geom_text(data = signals_short,
            aes(y = price, label = if_else(signal == "buy", "B", "S")),
            vjust = -0.6, fontface = "bold", color = "black", size = 5) +
  scale_color_manual(name = "Serie",
                     values = c("Cierre" = "blue", "SMA 3 días" = "red")) +
  labs(title = "AAPL: Cierre vs. SMA 3 días. Cinco señales.",
       x = "Fecha", y = "Precio (USD)") +
  theme_minimal(base_size = 12) +
  theme(legend.position = c(0.98, 0.98),
    legend.justification = c(1, 1),       
    legend.background = element_rect(fill = "white", color = NA),
    legend.key = element_rect(fill = "white", color = NA))
```

- 21-nov: `buy` a 271.49. Se abre posición larga. PnL realizado en este punto: 0. PnL acumulado previo: 24.89.

- 03-dic: `sell` a 284.15. Se cierra el largo y, en esquema always-in, se abre corto. PnL del tramo largo: 284.15 − 271.49 = 12.66. PnL acumulado: 24.89 + 12.66 = 37.55.

- 10-dic: `buy` a 278.78. Se cierra el corto abierto el 03-dic y se abre largo. PnL del tramo corto: 284.15 − 278.78 = 5.37. PnL acumulado: 37.55 + 5.37 = 42.92.

- 12-dic: `sell` a 278.28. Se cierra el largo abierto el 10-dic y se abre corto. PnL del tramo largo: 278.28 − 278.78 = −0.50. PnL acumulado: 42.92 − 0.50 = 42.42.

- 19-dic: `buy` a 273.67. Se cierra el corto abierto el 12-dic y se abre largo. PnL del tramo corto: 278.28 − 273.67 = 4.61. PnL acumulado: 42.42 + 4.61 = 47.03.


\newpage

# Descripción de 6 estrategias.

- Buy & hold: compras AAPL al primer cierre de 2025 y vendes el 12/dic/2025; PnL = diferencia entre esos cierres, sin trades intermedios.
- Trampa (short + long): abres corto al primer cierre de 2025, cubres y giras a largo en el mínimo anual (hasta 19/dic/2025) y cierras largo al final; capturas la caída y luego el rebote.
- Robo-trader: opera cada cruce cierre vs SMA3; cambia de lado en cada señal y liquida al cierre final; PnL suma cada tramo entre señales consecutivas.
- Aleatoria: 83 señales buy/sell alternadas en fechas al azar; PnL con la misma regla de cerrar y reabrir en cada señal, cierre forzado al final.
- Robo-omnisciente (benchmark ex-post): genera señales con la regla de cruces, pero ejecuta únicamente aquellas cuyo tramo posterior resulta con PnL positivo. Es un “oráculo” no implementable en tiempo real porque filtra operaciones usando información futura. Si aparecen señales del mismo tipo de forma consecutiva (buy–buy o sell–sell), se fuerza un cierre y reapertura al nuevo precio para que el PnL contabilice el tramo intermedio entre ambas ejecuciones.
- Robo-dumb (benchmark ex-post): usa la misma regla de cruces, pero ejecuta únicamente aquellas entradas cuyo tramo posterior resulta con PnL negativo. También es no implementable en tiempo real por depender de información futura. Ante señales consecutivas del mismo tipo, aplica el mismo mecanismo de cierre y reapertura para que el PnL refleje el tramo entre precios y capture correctamente los tramos desfavorables.


  \newpage

# Desempeño de las 6 estrategias.

```{r}
set.seed(123)
prices <- prices_ma3

P0 <- prices |> filter(date >= as.Date("2025-01-01")) |> slice_head(n = 1) |>
  pull(close)
bh_sell_px <- prices |> filter(date <= as.Date("2025-12-12")) |> slice_tail(n = 1) |> 
  pull(close)
Pmin <- prices |> filter(date >= as.Date("2025-01-01"), date <= final_date) |>
  slice_min(close, n = 1, with_ties = FALSE) |> pull(close)
Pend <- prices |> filter(date == final_date) |> pull(close)

buy_hold_gain <- bh_sell_px - P0
trampa_gain   <- (P0 - Pmin) + (Pend - Pmin)

trading_days <- prices |>
  filter(date >= start_date, date <= final_date) |>
  pull(date)

random_dates <- sort(sample(trading_days, size = 83, replace = FALSE))
start_side <- sample(c("buy", "sell"), 1)
random_signals_vec <- if (start_side == "buy") rep(c("buy", "sell"), length.out = 83) else 
  rep(c("sell", "buy"), length.out = 83)

signals_rand <- tibble(date = random_dates,
                       signal = random_signals_vec) |>
  left_join(prices |> select(date, close), by = "date") |>
  rename(price = close) |>
  arrange(date)

# Reuso de signal_outcomes ya calculado arriba
robo_trader_gain <- simulate_pnl(signals_rt, final_price = Pend)
random_gain <- simulate_pnl(signals_rand, final_price = Pend)
robo_omnisciente_gain <- simulate_pnl(signals_omniscient, final_price = Pend)
robo_dumb_gain <- simulate_pnl(signals_dumb, final_price = Pend)

rt_trades <- nrow(signals_rt)
rand_trades <- nrow(signals_rand)
omn_trades <- nrow(signals_omniscient)
dumb_trades <- nrow(signals_dumb)

strategies <- tibble(estrategia = c("Buy & hold", "Trampa", "Robo-trader",
                                    "Aleatoria", "Robo-omnisciente",
                                    "Robo-dumb"),
trades = c(NA_integer_, NA_integer_, rt_trades, rand_trades, omn_trades, 
           dumb_trades),
ganancia_simple = c(buy_hold_gain, trampa_gain, robo_trader_gain, random_gain,
                    robo_omnisciente_gain, robo_dumb_gain),
ganancia_por_trade = ganancia_simple / trades)

strategies_tbl <- strategies |>
  mutate(ganancia_simple = round(ganancia_simple, 2),
         ganancia_por_trade = round(ganancia_por_trade, 2))

strategies_tbl |>
  kable(digits = c(NA, 0, 2, 2))
```


\newpage

# Visualización del Robo-trader.

Hay señales correctas e incorrectas.

```{r}
signals_plot <- signals_rt |>
  left_join(signal_outcomes |> select(date, signal, correct),
            by = c("date", "signal")) |>
  mutate(correcto = if_else(correct, "Correcta", "Incorrecta"))

ggplot(rt_data, aes(date, close)) +
  geom_line(color = "gray35", linewidth = 0.4, alpha = 0.3) +
  geom_text(data = signals_plot,
            aes(y = price, label = if_else(signal == "buy", "B", "S"), 
                color = correcto), fontface = "bold", size = 3) +
  scale_color_manual(values = c(Correcta = "#2E8B57", Incorrecta = "red"), 
                     name = "Resultado") +
  geom_vline(xintercept = as.Date("2025-01-02"), linetype = "dashed", color = "gray50") +
  labs(title = "Robo-trader SMA3: Señales correctas vs incorrectas.",
       x = "Fecha", y = "Precio cierre (USD)") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom")
```

\newpage

# Visualización del Robo-omnisciente.

```{r}
signals_plot_omn <- signals_omniscient |>
  mutate(correcto = "Correcta")

ggplot(rt_data, aes(date, close)) +
  geom_line(color = "gray35", linewidth = 0.4, alpha = 0.3) +
  geom_text(data = signals_plot_omn,
            aes(y = price, label = if_else(signal == "buy", "B", "S"), color = correcto),
            fontface = "bold", size = 3) +
  scale_color_manual(values = c(Correcta = "#2E8B57"), name = "Resultado") +
  geom_vline(xintercept = as.Date("2025-01-02"), linetype = "dashed", color = "gray50") +
  labs(title = "Robo-omnisciente: Señales correctas.",
       x = "Fecha", y = "Precio cierre (USD)") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none")
```

\newpage

# Visualización del Robo-dumb.

```{r}
signals_plot_dumb <- signals_dumb |>
  mutate(correcto = "Incorrecta")

ggplot(rt_data, aes(date, close)) +
  geom_line(color = "gray35", linewidth = 0.4, alpha = 0.3) +
  geom_text(data = signals_plot_dumb,
            aes(y = price, label = if_else(signal == "buy", "B", "S"), color = correcto),
            fontface = "bold", size = 3) +
  scale_color_manual(values = c(Incorrecta = "red"), name = "Resultado") +
  geom_vline(xintercept = as.Date("2025-01-02"), linetype = "dashed", color = "gray50") +
  labs(title = "Robo-dumb: Señales incorrectas.",
       x = "Fecha", y = "Precio cierre (USD)") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none")
```


\newpage

# Bitácora Robo-trader.

```{r}
bitacora_num <- make_bitacora(signals_rt, final_date, Pend) |>
  mutate(price = round(price, 2),
         flujo = round(flujo, 2),
         PnL = round(PnL, 2),
         PnL_acum = round(PnL_acum, 2))

bitacora_num |>
  show_head_tail(n = 5) |>
  kable(digits = c(NA, NA, 2, 2, 2, 2))
```


- 03-dic: `sell` a 284.15. Se abre posición corta. PnL realizado en este punto: 0. PnL acumulado previo: 37.55.
- 10-dic: `buy` a 278.78. Se cierra el corto abierto el 03-dic y se abre largo. PnL del tramo corto: 284.15 − 278.78 = 5.37. PnL acumulado: 37.55 + 5.37 = 42.92.
- 12-dic: `sell` a 278.28. Se cierra el largo abierto el 10-dic y se abre corto. PnL del tramo largo: 278.28 − 278.78 = −0.50. PnL acumulado: 42.92 − 0.50 = 42.42.
- 19-dic: `buy` a 273.67. Se cierra el corto abierto el 12-dic y se abre largo. PnL del tramo corto: 278.28 − 273.67 = 4.61. PnL acumulado: 42.42 + 4.61 = 47.03.
- 19-dic: `final_close` a 273.67. Se cierra el largo abierto el 19-dic. PnL del tramo largo: 273.67 − 273.67 = 0.00. PnL acumulado final: 47.03.

\newpage

# Resumen Robo-trader.

```{r}
confusion <- signal_outcomes |>
  mutate(outcome = if_else(correct, "correcta", "incorrecta")) |>
  count(signal, outcome) |>
  pivot_wider(names_from = outcome, values_from = n, values_fill = 0)

confusion
```

\newpage

# Bitácora estrategia aleatoria.

```{r}
bitacora_aleatoria_num <- make_bitacora(signals_rand, final_date, Pend) |>
  mutate(price = round(price, 2),
         flujo = round(flujo, 2),
         PnL = round(PnL, 2),
         PnL_acum = round(PnL_acum, 2))

bitacora_aleatoria_num |>
  show_head_tail(n = 5) |>
  kable(digits = c(NA, NA, 2, 2, 2, 2))
```

\newpage

# Bitácora Robo-omnisciente.

```{r}
bitacora_omnisciente_num <- make_bitacora(signals_omniscient, final_date, Pend) |>
  mutate(price = round(price, 2),
         flujo = round(flujo, 2),
         PnL = round(PnL, 2),
         PnL_acum = round(PnL_acum, 2))

bitacora_omnisciente_num |>
  show_head_tail(n = 5) |>
  kable(digits = c(NA, NA, 2, 2, 2, 2))
```

- 13-nov: `sell` a 272.95. Se abre posición corta. PnL realizado en este punto: 0. PnL acumulado previo: 164.40.
- 21-nov: `buy` a 271.49. Se cierra el corto abierto el 13-nov y se abre largo. PnL del tramo corto: 272.95 − 271.49 = 1.46. PnL acumulado: 164.40 + 1.46 = 165.86.
- 03-dic: `sell` a 284.15. Se cierra el largo abierto el 21-nov y se abre corto. PnL del tramo largo: 284.15 − 271.49 = 12.66. PnL acumulado: 165.86 + 12.66 = 178.52.
- 12-dic: `sell` a 278.28. Señal repetida; se cierra el corto abierto el 03-dic y se reabre corto. PnL del tramo corto: 284.15 − 278.28 = 5.87. PnL acumulado: 178.52 + 5.87 = 184.39.
- 19-dic: `final_close` a 273.67. Se cierra el corto abierto el 12-dic. PnL del tramo corto: 278.28 − 273.67 = 4.61. PnL acumulado final: 189.00.


\newpage

# Bitácora Robo-dumb.

```{r}
bitacora_dumb_num <- make_bitacora(signals_dumb, final_date, Pend) |>
  mutate(price = round(price, 2),
         flujo = round(flujo, 2),
         PnL = round(PnL, 2),
         PnL_acum = round(PnL_acum, 2))

bitacora_dumb_num |>
  show_head_tail(n = 5) |>
  kable(digits = c(NA, NA, 2, 2, 2, 2))
```

- 19-nov: `buy` a 268.56. Se abre posición larga. PnL realizado en este punto: 0. PnL acumulado previo: −225.12.
- 20-nov: `sell` a 266.25. Se cierra el largo abierto el 19-nov y se abre corto. PnL del tramo largo: 266.25 − 268.56 = −2.31. PnL acumulado: −225.12 − 2.31 = −227.43.
- 10-dic: `buy` a 278.78. Se cierra el corto abierto el 20-nov y se abre largo. PnL del tramo corto: 266.25 − 278.78 = −12.53. PnL acumulado: −227.43 − 12.53 = −239.96.
- 19-dic: `buy` a 273.67. Señal repetida; se cierra el largo abierto el 10-dic y se reabre largo. PnL del tramo largo: 273.67 − 278.78 = −5.11. PnL acumulado: −239.96 − 5.11 = −245.07.
- 19-dic: `final_close` a 273.67. Se cierra el largo abierto el 19-dic. PnL del tramo largo: 273.67 − 273.67 = 0.00. PnL acumulado final: −245.07.


\newpage

# Ganancias Robo-trader.

```{r}
ggplot(signal_outcomes |> mutate(PnL_acum = cumsum(replace_na(trade_pnl, 0))),
       aes(x = date, y = PnL_acum)) +
  geom_line(color = "blue", linewidth = 1) +
  labs(title = "Robo-trader SMA3: Ganancia acumulada.",
       x = "Fecha", y = "Ganancia acumulada (USD)") +
  theme_minimal(base_size = 12)
```

\newpage

# Conclusión.

\Large 

\begin{itemize}
  \item La comparación evidencia cómo una regla mecánica SMA3 se posiciona frente a estrategias pasivas, un benchmark idealizado, ex-posts, y controles aleatorios.
  \item La bitácora y los gráficos permiten validar la lógica del algoritmo y la trazabilidad del PnL por operación.
  \item En conjunto, el ejercicio sirve como referencia metodológica para evaluar reglas de trading simplificado en términos de desempeño y frecuencia de operación.
\end{itemize}







